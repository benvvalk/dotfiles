#+TITLE: A Coder's Plover Dictionary
#+PROPERTY: header-args :tangle user.json

* about this config
I am a heavy user of emacs, vim, and the linux command line. When it comes to coding, the main challenge I have experienced with Plover is the automatic spacing and capitalization. While automatic spacing and capitalization is a big part of what makes stenography so efficient when typing natural language, it can wreak havoc in other contexts. For example, the unexpected insertion of spaces can interfere with the composition of normal mode commands in vim (e.g. "d3j" to delete the current line and the 3 lines below it). For this reason, I have overridden the default fingerspelling behavior to always attach the new letter/number to the end of the current word.

Another challenge is that there is no auto-repeat when holding down keys on a steno machine. This prevents you from holding down "j" and "k" to scroll up and down in vim, for example. You might be surprised how often you use this functionality, even if you are a seasoned vimmer. While I'm still working on it, I'm attempting to overcome this issue by using a combination of =relativenumber= and numeric arguments before j/k.
* start dictionary
#+BEGIN_SRC js
{
#+END_SRC
* bioinformatics
#+BEGIN_SRC js
"PWEUS": "ABySS",
"ARBGS": "arcs",
"A*RBGS": "arks",
"KOPB/TEUG": "contig",
"KOPB/TEUGS": "contigs",
"TKEUFT": "dist",
"EPL": "emc",
"PRAG": "pragma",
"KWAFT": "quast",
"SEUT/KA": "Sitka",
"TEUG/PHEUPBT": "Tigmint",
"AOUPB/TEUG": "unitig",
"AOUPB/TEUGS": "unitigs",
#+END_SRC

* brackets
#+BEGIN_SRC js
"HR-RPB": "{^}({^}",
"PW-RPB": "{^}[{^}",
"TK-RPB": "{^}\\{{^}",
"S-RPB":  "{^}<",
"S-RPBS":  "<<",
"PWR-FR": "{^})",
"PWR-PB": "{^}]",
"PWR-LG": "{^}\\}",
"PWR-TS": "{^}>",
"PWR-S": "{^}>",
#+END_SRC
* C/C++
#+BEGIN_SRC js
"KHR-PBS": "{^}::{^}",
"KRER": "cerr",
"KROUT": "cout",
"KOPBTS": "const",
"ST-D": "std{^}",
"STRUBGT": "struct",
"TAOEUP/TKEF": "typedef",
"TAOEUP/TPHAEUPL": "typename",
#+END_SRC
* command-line
** shell commands
#+BEGIN_SRC js
"POEUP": "{&../}",
"POEU": "{&./}",
"OEUP": "{&./}",
"TKR-": "cd",
"KR-D": "cd",
"KR-P": "cp",
"SKWRA*EUFPB": "json",
"HR-S": "ls",
"HR-PB": "ln",
"PH-D": "mkdir",
"PH-F": "mv",
"O*RG": "org",
"PW-D": "pwd",
"R-PL": "rm",
"R-D": "rmdir",
"SH": "ssh",
"TPHUBGS": "tmux",
"KPARGS": "xargs",
#+END_SRC
** command-line switches
#+BEGIN_SRC js
"TK-RB": "{MODE:RESET}{& --}",
"A-RBG": "{MODE:RESET}{& -a}",
"PW-RBG": "{MODE:RESET}{& -b}",
"KR-RBG": "{MODE:RESET}{& -c}",
"TK-RBG": "{MODE:RESET}{& -d}",
"-ERBG": "{MODE:RESET}{& -e}",
"TP-RBG": "{MODE:RESET}{& -f}",
"TKPW-RBG": "{MODE:RESET}{& -g}",
"H-RBG": "{MODE:RESET}{& -h}",
"-EUFP": "{MODE:RESET}{& -i}",
"SKWR-RBG": "{MODE:RESET}{& -j}",
"K-RBG": "{MODE:RESET}{& -k}",
"HR-RBG": "{MODE:RESET}{& -l}",
"PH-RBG": "{MODE:RESET}{& -m}",
"TPH-RBG": "{MODE:RESET}{& -n}",
"O-RBG": "{MODE:RESET}{& -o}",
"P-RBG": "{MODE:RESET}{& -p}",
"KW-RBG": "{MODE:RESET}{& -q}",
"R-RBG": "{MODE:RESET}{& -r}",
"S-RBG": "{MODE:RESET}{& -s}",
"T-RBG": "{MODE:RESET}{& -t}",
"-URBG": "{MODE:RESET}{& -u}",
"SR-RBG": "{MODE:RESET}{& -v}",
"W-RBG": "{MODE:RESET}{& -w}",
"KP-RBG": "{MODE:RESET}{& -x}",
"KPR-RBG": "{MODE:RESET}{& -y}",
"STKPW-RBG": "{MODE:RESET}{& -z}",
"A-RPBG": "{MODE:RESET}{& -A}",
"PW-RPBG": "{MODE:RESET}{& -B}",
"KR-RPBG": "{MODE:RESET}{& -C}",
"TK-RPBG": "{MODE:RESET}{& -D}",
"-EF": "{MODE:RESET}{& -E}",
"KPWR-E": "{MODE:RESET}{& -E}",
"TP-RPBG": "{MODE:RESET}{& -F}",
"TKPW-RPBG": "{MODE:RESET}{& -G}",
"H-RPBG": "{MODE:RESET}{& -H}",
"-EUFPL": "{MODE:RESET}{& -I}",
"KPWR-EU": "{MODE:RESET}{& -I}",
"SKWR-RPBG": "{MODE:RESET}{& -J}",
"K-RPBG": "{MODE:RESET}{& -K}",
"HR-RPBG": "{MODE:RESET}{& -L}",
"TPH-RPBG": "{MODE:RESET}{& -M}",
"TPH-RPBG": "{MODE:RESET}{& -N}",
"O-RPBG": "{MODE:RESET}{& -O}",
"P-RPBG": "{MODE:RESET}{& -P}",
"KW-RPBG": "{MODE:RESET}{& -Q}",
"R-RPBG": "{MODE:RESET}{& -R}",
"S-RPBG": "{MODE:RESET}{& -S}",
"T-RPBG": "{MODE:RESET}{& -T}",
"-URPBG": "{MODE:RESET}{& -U}",
"KPWR-U": "{MODE:RESET}{& -U}",
"SR-RPBG": "{MODE:RESET}{& -V}",
"W-RPBG": "{MODE:RESET}{& -W}",
"KP-RPBG": "{MODE:RESET}{& -X}",
"KPR-RPBG": "{MODE:RESET}{& -Y}",
"STKPW-RPBG": "{MODE:RESET}{& -Z}",
#+END_SRC
* function keys
To type a function key (e.g. F1), hold down -PL and fingerspell the number with the left hand. The mnemonic for -PL is that it is the mirror image for fingerspelling "F" with the left hand.
#+BEGIN_SRC js
"178": "{#F1}",
"278": "{#F2}",
"378": "{#F3}",
"478": "{#F4}",
"578": "{#F5}",
"678": "{#F6}",
"778": "{#F7}",
"878": "{#F8}",
"978": "{#F9}",
"1078": "{#F10}",
"1278": "{#F12}",
#+END_SRC
* coding
** expressions/assignment

#+BEGIN_SRC js
"KWA*L": "{MODE:RESET}{^=^}{MODE:LOWER}{MODE:SET_SPACE:}",
"KWA*LS": "{MODE:RESET}{^ = ^}{MODE:LOWER}{MODE:SET_SPACE:}",
"KW*LT": "{MODE:RESET}{^ == ^}{MODE:LOWER}{MODE:SET_SPACE:}",
"K*PL": "{MODE:RESET}{^, ^}{MODE:LOWER}{MODE:SET_SPACE:}",
"KR*PL": "{MODE:RESET}{^, ^}{MODE:LOWER}{MODE:SET_SPACE:}",
"HR*T": "{MODE:RESET}{^ < ^}{MODE:LOWER}{MODE:SET_SPACE:}",
"HR*ET": "{MODE:RESET}{^ <= ^}{MODE:LOWER}{MODE:SET_SPACE:}",
"TKPW*T": "{MODE:RESET}{^ > ^}{MODE:LOWER}{MODE:SET_SPACE:}",
"TKPW*ET": "{MODE:RESET}{^ >= ^}{MODE:LOWER}{MODE:SET_SPACE:}",
"HR*PBD": "{MODE:RESET}{^ && ^}{MODE:LOWER}{MODE:SET_SPACE:}",
"HRO*R": "{MODE:RESET}{^ || ^}{MODE:LOWER}{MODE:SET_SPACE:}",
#+END_SRC

* modifier keys (alt/control/shift/win)
** alt
#+BEGIN_SRC js
"KHR*FPB": "{#alt(shift(colon))}",
"P*FP": "{#alt(period)}",
"S*FP": "{#alt(space)}",
"SH*P": "{#alt(space)}",
"HO*EU": "{#alt(slash)}",
"O*EUF": "{#alt(slash)}",
"T*FB": "{#alt(tab)}",
"TH*B": "{#alt(tab)}",
"A*F": "{#alt(a)}",
"PW*F": "{#alt(b)}",
"KR*F": "{#alt(c)}",
"TK*F": "{#alt(d)}",
"*EF": "{#alt(e)}",
"H*E": "{#alt(e)}",
"TP*F": "{#alt(f)}",
"TKPW*F": "{#alt(g)}",
"H*F": "{#alt(h)}",
"*EUF": "{#alt(i)}",
"H*EU": "{#alt(i)}",
"SKWR*F": "{#alt(j)}",
"K*F": "{#alt(k)}",
"HR*F": "{#alt(l)}",
"PH*F": "{#alt(m)}",
"TPH*F": "{#alt(n)}",
"O*F": "{#alt(o)}",
"P*F": "{#alt(p)}",
"KW*F": "{#alt(q)}",
"R*F": "{#alt(r)}",
"S*F": "{#alt(s)}",
"T*F": "{#alt(t)}",
"*UF": "{#alt(u)}",
"W*U": "{#alt(u)}",
"SR*F": "{#alt(v)}",
"W*F": "{#alt(w)}",
"KP*F": "{#alt(x)}",
"KWR*F": "{#alt(y)}",
"STKPW*F": "{#alt(z)}",
#+END_SRC
** control
#+BEGIN_SRC js
"0*R": "{#control(0)}",
"1*R": "{#control(1)}",
"2*R": "{#control(2)}",
"3*R": "{#control(3)}",
"4*R": "{#control(4)}",
"5*R": "{#control(5)}",
"R*6": "{#control(6)}",
"R*7": "{#control(7)}",
"R*8": "{#control(8)}",
"R*9": "{#control(9)}",
"HR*RPB": "{#control(parenleft)}",
"PW*RPB": "{#control(bracketleft)}",
"TK*RPB": "{#control(braceleft)}",
"PWR*FR": "{#control(parenright)}",
"PWR*PB": "{#control(bracketright)}",
"PWR*LG": "{#control(braceright)}",
"KHR-R": "{#control(left)}",
"KHR-G": "{#control(right)}",
"KHR-P": "{#control(up)}",
"KHR-B": "{#control(down)}",
"R*EUPBS": "{#control(insert)}",
"R*T": "{#control(shift(plus))}",
"R*S": "{#control(minus)}",
"RO*EU": "{#control(slash)}",
"O*EUR": "{#control(slash)}",
"S*RP": "{#control(space)}",
"T*RB": "{#control(tab)}",
"TR*B": "{#control(tab)}",
"A*R": "{#control(a)}",
"PW*R": "{#control(b)}",
"KR*R": "{#control(c)}",
"TK*R": "{#control(d)}",
"R*E": "{#control(e)}",
"TP*R": "{#control(f)}",
"TKPW*R": "{#control(g)}",
"H*R": "{#control(h)}",
"*EUR": "{#control(i)}",
"R*EU": "{#control(i)}",
"SKWR*R": "{#control(j)}",
"K*R": "{#control(k)}",
"HR*R": "{#control(l)}",
"PH*R": "{#control(m)}",
"TPH*R": "{#control(n)}",
"O*R": "{#control(o)}",
"P*R": "{#control(p)}",
"KW*R": "{#control(q)}",
"R*R": "{#control(r)}",
"S*R": "{#control(s)}",
"T*R": "{#control(t)}",
"*UR": "{#control(u)}",
"R*U": "{#control(u)}",
"SR*R": "{#control(v)}",
"W*R": "{#control(w)}",
"KP*R": "{#control(x)}",
"KWR*R": "{#control(y)}",
"STKPW*R": "{#control(z)}",
#+END_SRC
** shift
#+BEGIN_SRC js
"SH*EUPBS": "{#shift(insert)}",
"SH*P": "{#shift(up)}",
"SH*B": "{#shift(down)}",
"SH*R": "{#shift(left)}",
"SH*G": "{#shift(right)}",
"SH*RB": "{#shift(control(left))}",
"SH*BG": "{#shift(control(right))}",
"ST*B": "{#shift(tab)}",
"T*BS": "{#shift(tab)}",
#+END_SRC
** win
#+BEGIN_SRC js
"*PB": "{#windows}",
"R*RPB": "{#windows(return)}",
"PWR*R": "{#windows(return)}",
"P*LG": "{#windows(up)}",
"K*LG": "{#windows(left)}",
"W*LG": "{#windows(down)}",
"R*LG": "{#windows(right)}",
"A*PB": "{#windows(a)}",
"PW*PB": "{#windows(b)}",
"KR*PB": "{#windows(c)}",
"TK*PB": "{#windows(d)}",
"*EPB": "{#windows(e)}",
"TP*PB": "{#windows(f)}",
"TKPW*PB": "{#windows(g)}",
"H*PB": "{#windows(h)}",
"*EUPB": "{#windows(i)}",
"SKWR*PB": "{#windows(j)}",
"K*PB": "{#windows(k)}",
"HR*PB": "{#windows(l)}",
"PH*PB": "{#windows(m)}",
"TPH*PB": "{#windows(n)}",
"O*PB": "{#windows(o)}",
"P*PB": "{#windows(p)}",
"KW*PB": "{#windows(q)}",
"R*PB": "{#windows(r)}",
"S*PB": "{#windows(s)}",
"T*PB": "{#windows(t)}",
"*UPB": "{#windows(u)}",
"SR*PB": "{#windows(v)}",
"W*PB": "{#windows(w)}",
"KP*PB": "{#windows(x)}",
"KWR*PB": "{#windows(y)}",
"STKPW*PB": "{#windows(z)}",
#+END_SRC
** win+shift
Same as the Windows key chords, but with the S key appended at the end.
#+BEGIN_SRC js
"A*PBS": "{#windows(shift(a))}",
"PW*PBS": "{#windows(shift(b))}",
"KR*PBS": "{#windows(shift(c))}",
"TK*PBS": "{#windows(shift(d))}",
"*EPBS": "{#windows(shift(e))}",
"TP*PBS": "{#windows(shift(f))}",
"TKPW*PBS": "{#windows(shift(g))}",
"H*PBS": "{#windows(shift(h))}",
"*EUPBS": "{#windows(shift(i))}",
"SKWR*PBS": "{#windows(shift(j))}",
"K*PBS": "{#windows(shift(k))}",
"HR*PBS": "{#windows(shift(l))}",
"PH*PBS": "{#windows(shift(m))}",
"TPH*PBS": "{#windows(shift(n))}",
"O*PBS": "{#windows(shift(o))}",
"P*PBS": "{#windows(shift(p))}",
"KW*PBS": "{#windows(shift(q))}",
"R*PBS": "{#windows(shift(r))}",
"S*PBS": "{#windows(shift(s))}",
"T*PBS": "{#windows(shift(t))}",
"*UPBS": "{#windows(shift(u))}",
"SR*PBS": "{#windows(shift(v))}",
"W*PBS": "{#windows(shift(w))}",
"KP*PBS": "{#windows(shift(x))}",
"KWR*PBS": "{#windows(shift(y))}",
"STKPW*PBS": "{#windows(shift(z))}",
#+END_SRC

* escape key

Pressing the number bar on its own triggers the Esc key and returns us to the default Plover mode, where automatic capitalization and spacing are disabled.

#+BEGIN_SRC js
"#": "{#escape}{MODE:RESET}{MODE:LOWER}{MODE:SET_SPACE:}",
"#*": "{#escape}",
#+END_SRC
* fingerspelling
In this section, we override the default behavior of fingerspelling to attach all fingerspelled letters/symbols/numbers to the end of the current word. This prevents Plover's automatic spacing from interfering with the typing of normal mode commands in vim.
** letters
#+BEGIN_SRC js
"A*": "{^}a{^}",
"PW*": "{^}b{^}",
"KR*": "{^}c{^}",
"TK*": "{^}d{^}",
"*E": "{^}e{^}",
"TP*": "{^}f{^}",
"TKPW*": "{^}g{^}",
"H*": "{^}h{^}",
"*EU": "{^}i{^}",
"SKWR*": "{^}j{^}",
"K*": "{^}k{^}",
"HR*": "{^}l{^}",
"PH*": "{^}m{^}",
"TPH*": "{^}n{^}",
"O*": "{^}o{^}",
"P*": "{^}p{^}",
"KW*": "{^}q{^}",
"R*": "{^}r{^}",
"S*": "{^}s{^}",
"T*": "{^}t{^}",
"*U": "{^}u{^}",
"SR*": "{^}v{^}",
"W*": "{^}w{^}",
"KP*": "{^}x{^}",
"KWR*": "{^}y{^}",
"STKPW*": "{^}z{^}",
"A*P": "{MODE:RESET}{^}A{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"PW*P": "{MODE:RESET}{^}B{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"KR*P": "{MODE:RESET}{^}C{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"TK*P": "{MODE:RESET}{^}D{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"*EP": "{MODE:RESET}{^}E{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"P*E": "{MODE:RESET}{^}E{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"TP*P": "{MODE:RESET}{^}F{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"TKPW*P": "{MODE:RESET}{^}G{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"H*P": "{MODE:RESET}{^}H{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"*EUP": "{MODE:RESET}{^}I{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"P*EU": "{MODE:RESET}{^}I{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"SKWR*P": "{MODE:RESET}{^}J{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"K*P": "{MODE:RESET}{^}K{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"HR*P": "{MODE:RESET}{^}L{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"PH*P": "{MODE:RESET}{^}M{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"TPH*P": "{MODE:RESET}{^}N{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"O*P": "{MODE:RESET}{^}O{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"P*P": "{MODE:RESET}{^}P{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"KW*P": "{MODE:RESET}{^}Q{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"R*P": "{MODE:RESET}{^}R{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"S*P": "{MODE:RESET}{^}S{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"T*P": "{MODE:RESET}{^}T{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"*UP": "{MODE:RESET}{^}U{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"P*U": "{MODE:RESET}{^}U{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"SR*P": "{MODE:RESET}{^}V{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"W*P": "{MODE:RESET}{^}W{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"KP*P": "{MODE:RESET}{^}X{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"KWR*P": "{MODE:RESET}{^}Y{^}{MODE:LOWER}{MODE:SET_SPACE:}",
"STKPW*P": "{MODE:RESET}{^}Z{^}{MODE:LOWER}{MODE:SET_SPACE:}",
#+END_SRC
** numbers
#+BEGIN_SRC js
"0": "{^}0",
"1": "{^}1",
"2": "{^}2",
"3": "{^}3",
"4": "{^}4",
"5": "{^}5",
"6": "{^}6",
"7": "{^}7",
"8": "{^}8",
"9": "{^}9",
"10-EU": "{^}01",
"20-EU": "{^}02",
"30-EU": "{^}03",
"40-EU": "{^}04",
"50-EU": "{^}05",
"60-EU": "{^}06",
"70-EU": "{^}07",
"80-EU": "{^}08",
"90-EU": "{^}09",
"01-EU": "{^}10",
"12": "{^}12",
"13": "{^}13",
"14": "{^}14",
"15": "{^}15",
"16": "{^}16",
"17": "{^}17",
"18": "{^}18",
"19": "{^}19",
"02-EU": "{^}20",
"12-EU": "{^}21",
"23": "{^}23",
"24": "{^}24",
"25": "{^}25",
"26": "{^}26",
"27": "{^}27",
"28": "{^}28",
"29": "{^}29",
"03-EU": "{^}30",
"13-EU": "{^}31",
"23-EU": "{^}32",
"34": "{^}34",
"35": "{^}35",
"36": "{^}36",
"37": "{^}37",
"38": "{^}38",
"39": "{^}39",
#+END_SRC
** symbol chars (e.g. !, @, #)
Assign these to the number keys, similar to a normal keyboard, using the star key ("*") as the modifier.
#+BEGIN_SRC js
"0*": "{^})",
"1*": "{^}!",
"2*": "{^}@",
"3*": "{^}#",
"4*": "{^}$",
"5*": "{^}%",
"*6": "{^}^",
"*7": "{^}&",
"*8": "{^}*",
"*9": "{^}(",
#+END_SRC
** digrams

I find the ability to fingerspell digrams (two-letter combinations) to be very handy. For example, I have used various vim plugins for Firefox/Chrome (e.g. Vimperator, Vimium, VimFX, tridactyl) that allow keyboard navigation of hyperlinks by labeling the links with two-letter "hints".

The idea behind these chords is to fingerspell the first letter with the left hand as usual, and to use the right hand to fingerspell the second letter. The chords for fingerspelling with the right hand are the mirror image of the chords for the left hand. For example, the right hand chord for "m" is -FP. Finally, all digram chords end with the Z key.

#+NAME: digrams
#+BEGIN_SRC python :tangle no :results output silent
# fingerspelling chords for the left hand
l = {}
l['a'] = "A"
l['b'] = "PW"
l['c'] = "KR"
l['d'] = "TK"
l['f'] = "TP"
l['g'] = "TKPW"
l['h'] = "H"
l['j'] = "SKWR"
l['k'] = "K"
l['l'] = "HR"
l['m'] = "PH"
l['n'] = "TPH"
l['o'] = "O"
l['p'] = "P"
l['q'] = "KW"
l['r'] = "R"
l['s'] = "S"
l['t'] = "T"
l['v'] = "SR"
l['w'] = "W"
l['x'] = "KP"
l['y'] = "KWR"
l['z'] = "STKPW"

# fingerspelling chords for the right hand
r = {}
r['b'] = "PB"
r['c'] = "RG"
r['d'] = "LG"
r['e'] = "E"
r['f'] = "PL"
r['g'] = "PBLG"
r['h'] = "F"
r['i'] = "EU"
r['j'] = "RBGS"
r['k'] = "G"
r['l'] = "FR"
r['m'] = "FP"
r['n'] = "FPL"
r['p'] = "P"
r['q'] = "BG"
r['r'] = "R"
r['s'] = "S"
r['t'] = "L"
r['u'] = "U"
r['v'] = "RS"
r['w'] = "B"
r['x'] = "PG"
r['y'] = "RBG"
r['z'] = "PBLGS"

for key1, value1 in l.iteritems():
    for key2, value2 in r.iteritems():
        # both letters lowercase
        print('"{}-{}Z": "{{^{}{}^}}",'.format(value1,value2,key1,key2))
        # first letter uppercase
        print('"{}*-{}Z": "{{^{}{}^}}",'.format(value1,value2,key1.upper(),key2))
        # second letter uppercase
        print('"{}-{}DZ": "{{^{}{}^}}",'.format(value1,value2,key1,key2.upper()))
        # both letters uppercase
        print('"{}*-{}DZ": "{{^{}{}^}}",'.format(value1,value2,key1.upper(),key2.upper()))

# number-letter combos

ldigit = ["0","1","2","3","4","5","O*","K","W","R"]

for i in xrange(1, 99):
    for key2, value2 in r.iteritems():
        # EU is reserved for inverting digits
        if key2 == "i":
            continue
        if i < 10:
            if i <= 5: # single digit number
                print('"{}-{}Z": "{{^{}{}^}}",'.format(ldigit[i],value2,i,key2))
            else:
                print('"#{}-{}Z": "{{^{}{}^}}",'.format(ldigit[i],value2,i,key2))
        else: # double digit number
            digit1 = i // 10
            digit2 = i % 10
            if digit1 <= 5 or digit2 <= 5:
                if digit1 == digit2:
                    continue # not sure how to handle this case
                if digit1 > digit2:
                    print('"{}{}-EU{}Z": "{{^{}{}^}}",'.format(digit2,digit1,value2,i,key2))
                else:
                    print('"{}-{}Z": "{{^{}{}^}}",'.format(i,value2,i,key2))
            else:
                if digit1 == digit2:
                    continue # not sure how to handle this case
                if digit1 > digit2:
                    print('"#{}{}-EU{}Z": "{{^{}{}^}}",'.format(ldigit[digit2],ldigit[digit1],value2,i,key2))
                else:
                    print('"#{}{}-{}Z": "{{^{}{}^}}",'.format(ldigit[digit1],ldigit[digit2],value2,i,key2))
#+END_SRC

#+BEGIN_SRC js :noweb tangle
<<digrams()>>
#+END_SRC
** trigrams

Handy trigrams for vim.

#+BEGIN_SRC js
"KR-EUBZ": "{^ciw^}",
"KRA-BZ": "{^caw^}",
"KR-EUGSZ": "{^ci\"^}",
"KRA-GSZ": "{^ca\"^}",
"KRA-BZ": "{^caw^}",
"TK-EUBZ": "{^diw^}",
"TKA-BZ": "{^daw^}",
#+END_SRC

* people's names
#+BEGIN_SRC js
"TPHAFRPB": "Inanc",
"REPB/AEU": "Rene",
"RUP": "Rup",
"RAOUP": "Rup",
"SHAUPB": "Shaun",
#+END_SRC
* Plover meta commands
** capitalization

   Capitalize the next word.
#+BEGIN_SRC js
"KPA": "{MODE:RESET}{-|}",
#+END_SRC

Capitalize the next word and join it to the end of the current word (suppress automatic spacing).
#+BEGIN_SRC js
"KPA*": "{MODE:RESET}{^}{-|}",
#+END_SRC

Retroactively capitalize the last word.
#+BEGIN_SRC js
"KPA-D": "{MODE:RESET}{*-|}",
#+END_SRC

Retroactively lowercase the last word. (Mnemonic: "U" for uncapitalize.)
#+BEGIN_SRC js
"KPA-UD": "{*>}",
#+END_SRC

Make the next word all uppercase/lowercase.
#+BEGIN_SRC js
"HRO*ER": "{>}",
#+END_SRC

Retroactively lowercase/uppercase.
#+BEGIN_SRC js
"-FRD": "{MODE:RESET}{*>}",
"-RGD": "{MODE:RESET}{*<}",
#+END_SRC

** dictionary lookup
  Open up Plover's handy reverse dictionary lookup dialog, where one can type (fingerspell) any word and see what steno chords generate that word.
#+BEGIN_SRC js
"TKHRUP": "{PLOVER:LOOKUP}",
#+END_SRC
** Plover modes (e.g. all-caps)
#+BEGIN_SRC js
"TK*PL": "{MODE:RESET}",
"R*PL": "{MODE:RESET}",
"P*PL": "{MODE:LOWER}{MODE:SET_SPACE:}",
"HR*PL": "{MODE:LOWER}{MODE:SET_SPACE: }",
#+END_SRC
** spacing

Override the default space key binding to insert a space, even when the space character is "". (The space character is "" whenever we are in the default mode, where automatic capitalization and automatic spacing are disabled. We return to the default mode whenever we press Escape.)

#+BEGIN_SRC js
"S-P": "{MODE:RESET}{^ ^}{MODE:LOWER}{MODE:SET_SPACE:}",
#+END_SRC

Retroactively insert a space before the last word.
#+BEGIN_SRC js
"-FPD": "{MODE:RESET}{*?}",
"S-PD": "{MODE:RESET}{*?}",
#+END_SRC

Retroactively delete a space before the last word.
#+BEGIN_SRC js
"TK-FPD": "{*!}",
#+END_SRC

Attach the next word to the end of the current word.
#+BEGIN_SRC js
"SKHR-PB": "{^};",
#+END_SRC
* vertical jumps

This section provides chords for jumping up or down a given number of lines.

To jump by a certain number of lines, fingerspell the number as usual, but append the D/Z key to the chord to indicate up/down.

#+NAME: vertical-jumps
#+BEGIN_SRC python :tangle no :results output silent
for i in xrange(1, 99):
    if i <= 5:
            print('"{}-D": "{{^}}{{#{}}}",'.format(i, ' '.join(["up"]*i)))
            print('"{}-Z": "{{^}}{{#{}}}",'.format(i, ' '.join(["down"]*i)))
    elif i < 10:
            print('"-{}D": "{{^}}{{#{}}}",'.format(i, ' '.join(["up"]*i)))
            print('"-{}Z": "{{^}}{{#{}}}",'.format(i, ' '.join(["down"]*i)))
    else:
            digit1 = i // 10
            digit2 = i % 10
            swap_keys = ''
            if digit1 > digit2 and digit2 > 0:
                    digit1, digit2 = digit2, digit1
                    swap_keys = 'EU'
            if digit1 <= 5 and digit2 <= 5:
                    chord = '{}{}-{}'.format(digit1, digit2, swap_keys)
            if digit1 <= 5 and digit2 > 5:
                    chord = '{}-{}{}'.format(digit1, swap_keys, digit2)
            if digit1 > 5 and digit2 > 5:
                    chord = '-{}{}{}'.format(swap_keys, digit1, digit2)
            print('"{}D": "{{^}}{{#{}}}",'.format(chord, ' '.join(["up"]*i)))
            print('"{}Z": "{{^}}{{#{}}}",'.format(chord, ' '.join(["down"]*i)))
#+END_SRC

#+BEGIN_SRC js :noweb tangle
<<vertical-jumps()>>
#+END_SRC

* uncategorized
#+BEGIN_SRC js
"*T": "{*}",
"*FP": "{#space}",
"UFP": "{^}_{^}",
"TK-FP": "{^}",
"SPWR-TS": ">>",
"SPWR-S": ">>",
"T-B": "{#tab}",
"T-PB": "{#shift(tab)}",
"TP-B": "{#shift(tab)}",
"STPH-T": "{#page_up}",
"STPH-S": "{#page_down}",
"*F": "{#page_up}",
"*R": "{#page_down}",
"*P": "{#home}",
"STPH-F": "{#home}",
"*L": "{#end}",
"STPH-L": "{#end}"
#+END_SRC

* end dictionary
#+BEGIN_SRC js
}
#+END_SRC
