* EXWM
** Init
#+BEGIN_SRC emacs-lisp
(require 'exwm)
(require 'exwm-config)
#+END_SRC
** Buffer Names
#+BEGIN_SRC emacs-lisp
;; All buffers created in EXWM mode are named "*EXWM*". You may want to change
;; it in `exwm-update-class-hook' and `exwm-update-title-hook', which are run
;; when a new window class name or title is available. Here's some advice on
;; this subject:
;; + Always use `exwm-workspace-rename-buffer` to avoid naming conflict.
;; + Only renaming buffer in one hook and avoid it in the other. There's no
;;   guarantee on the order in which they are run.
;; + For applications with multiple windows (e.g. GIMP), the class names of all
;;   windows are probably the same. Using window titles for them makes more
;;   sense.
;; + Some application change its title frequently (e.g. browser, terminal).
;;   Its class name may be more suitable for such case.
;; In the following example, we use class names for all windows expect for
;; Java applications and GIMP.
(add-hook 'exwm-update-class-hook
          (lambda ()
            (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                        (string= "gimp" exwm-instance-name))
              (exwm-workspace-rename-buffer exwm-class-name))))
(add-hook 'exwm-update-title-hook
          (lambda ()
            (when (or (not exwm-instance-name)
                      (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                      (string= "gimp" exwm-instance-name))
              (exwm-workspace-rename-buffer exwm-title))))
#+END_SRC
** Locking the Screen
#+BEGIN_SRC emacs-lisp
;; + 'slock' is a simple X display locker provided by suckless tools.
(exwm-input-set-key (kbd "s-<f2>")
                    (lambda () (interactive) (start-process "" nil "slock")))
#+END_SRC
** Modeline and Minibuffer
#+BEGIN_SRC emacs-lisp
;; You can hide the mode-line of floating X windows by uncommenting the
;; following lines
;(add-hook 'exwm-floating-setup-hook #'exwm-layout-hide-mode-line)
;(add-hook 'exwm-floating-exit-hook #'exwm-layout-show-mode-line)

;; You can hide the minibuffer and echo area when they're not used, by
;; uncommenting the following line
;(setq exwm-workspace-minibuffer-position 'bottom)
#+END_SRC
** Redirecting Keyboard Input
#+BEGIN_SRC emacs-lisp
;; The following example demonstrates how to set a key binding only available
;; in line mode. It's simply done by first push the prefix key to
;; `exwm-input-prefix-keys' and then add the key sequence to `exwm-mode-map'.
;; The example shorten 'C-c q' to 'C-q'.
(push ?\C-q exwm-input-prefix-keys)
(push (kbd "M-m") exwm-input-prefix-keys)
(define-key exwm-mode-map [?\C-q] #'exwm-input-send-next-key)

;; Note: these bindings are overridden below.  I should choose some new bindings.
(exwm-input-set-key (kbd "s-r") #'exwm-reset)
(exwm-input-set-key (kbd "s-l") #'exwm-input-grab-keyboard)

;; The following example demonstrates how to use simulation keys to mimic the
;; behavior of Emacs. The argument to `exwm-input-set-simulation-keys' is a
;; list of cons cells (SRC . DEST), where SRC is the key sequence you press and
;; DEST is what EXWM actually sends to application. Note that SRC must be a key
;; sequence (of type vector or string), while DEST can also be a single key.
(exwm-input-set-simulation-keys
 '(([?\C-b] . left)
   ([?\C-f] . right)
   ([?\C-p] . up)
   ([?\C-n] . down)
   ([?\C-a] . home)
   ([?\C-e] . end)
   ([?\M-v] . prior)
   ([?\C-v] . next)
   ([?\C-d] . delete)
   ([?\C-k] . (S-end delete))))
#+END_SRC
** Starting/Killing Programs
#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "s-p") #'helm-run-external-command)
(exwm-input-set-key (kbd "C-M-p") #'helm-run-external-command)
(exwm-input-set-key (kbd "s-x") #'kill-this-buffer)
(exwm-input-set-key (kbd "C-M-x") #'kill-this-buffer)

;; + Application launcher ('M-&' also works if the output buffer does not
;;   bother you). Note that there is no need for processes to be created by
;;   Emacs.
(exwm-input-set-key (kbd "s-&")
                    (lambda (command)
                      (interactive (list (read-shell-command "$ ")))
                      (start-process-shell-command command nil command)))
#+END_SRC
** Window and Buffer Manipulation
#+BEGIN_SRC emacs-lisp
(exwm-input-set-key (kbd "s-f") #'spacemacs/toggle-maximize-buffer)
(exwm-input-set-key (kbd "C-M-f") #'spacemacs/toggle-maximize-buffer)
(exwm-input-set-key (kbd "s-j") #'evil-window-next)
(exwm-input-set-key (kbd "C-M-j") #'evil-window-next)
(exwm-input-set-key (kbd "s-k") #'evil-window-prev)
(exwm-input-set-key (kbd "C-M-k") #'evil-window-prev)
(exwm-input-set-key (kbd "s-l") #'spacemacs/alternate-buffer)
(exwm-input-set-key (kbd "C-M-l") #'spacemacs/alternate-buffer)
(exwm-input-set-key (kbd "s-b") #'helm-mini)
(exwm-input-set-key (kbd "C-M-b") #'helm-mini)
(exwm-input-set-key (kbd "s-s") #'evil-window-split)
(exwm-input-set-key (kbd "C-M-s") #'evil-window-split)
(exwm-input-set-key (kbd "s-u") #'winner-undo)
(exwm-input-set-key (kbd "C-M-u") #'winner-undo)
(exwm-input-set-key (kbd "s-r") #'winner-undo)
(exwm-input-set-key (kbd "C-M-r") #'winner-undo)
(exwm-input-set-key (kbd "s-v") #'evil-window-vsplit)
(exwm-input-set-key (kbd "C-M-v") #'evil-window-vsplit)
#+END_SRC
** Workspaces
#+BEGIN_SRC emacs-lisp
;; Set the initial number of workspaces.
(setq exwm-workspace-number 2)

;; Interactive prompt to switch workspaces
(exwm-input-set-key (kbd "s-w") #'exwm-workspace-switch)

;; + Bind "s-0" to "s-9" and "C-M-0" to "C-M-9" to
;; switch to the corresponding workspace.
(dotimes (i 10)
  (exwm-input-set-key (kbd (format "s-%d" i))
                      `(lambda ()
                         (interactive)
                         (exwm-workspace-switch-create ,i)))
  (exwm-input-set-key (kbd (format "C-M-%d" i))
                      `(lambda ()
                         (interactive)
                         (exwm-workspace-switch-create ,i))))
#+END_SRC
** Multi-Monitor Setup
#+BEGIN_SRC emacs-lisp
(require 'exwm-randr)
(setq exwm-randr-workspace-output-plist '(1 "DP-1" 2 "DVI-I-0"))
;(add-hook 'exwm-randr-screen-change-hook
;          (lambda ()
;			(progn
;			  (start-process-shell-command
;			   "xrandr" nil "xrandr --output DVI-I-0 --right-of DP-1")
;			  (start-process-shell-command
;			   "xrandr" nil "xrandr --output DVI-I-0 --primary"))))
(exwm-randr-enable)
#+END_SRC
** Enable/Disable EXWM
#+BEGIN_SRC emacs-lisp
;; Do not forget to enable EXWM. It will start by itself when things are ready.
(exwm-enable)
#+END_SRC
* Load Path
#+BEGIN_SRC emacs-lisp
(add-to-list 'load-path "~/.emacs.d/private/local")
#+END_SRC
* Autocompletion
#+BEGIN_SRC emacs-lisp
;; enable autocomplete always
(global-company-mode)
;; don't bring up autocomplete menu automatically
(setq company-idle-delay nil)
;; main autocomplete params
(setq-default dotspacemacs-configuration-layers '(
  (auto-completion :variables
                   auto-completion-return-key-behavior 'complete
                   auto-completion-tab-key-behavior 'complete-selection
                   auto-completion-complete-with-key-sequence nil
                   auto-completion-private-snippets-directory nil)))

(with-eval-after-load 'company
	(define-key company-active-map (kbd "TAB") 'company-complete-selection)
	(define-key company-active-map (kbd "C-n") 'company-select-next)
	(define-key company-active-map (kbd "C-p") 'company-select-previous))
#+END_SRC
* Avy
** Aesthetics
#+BEGIN_SRC emacs-lisp
;; don't grey out the background when prompting for jump target
(setq avy-background nil)
;; make avy jump hints more readable
(custom-set-faces
 '(default ((t (:background nil))))
 '(avy-lead-face ((t (:foreground "red" :background "white"))))
 '(avy-lead-face-0 ((t (:foreground "red" :background "white"))))
 '(avy-lead-face-1 ((t (:foreground "red" :background "white"))))
 '(avy-lead-face-2 ((t (:foreground "red" :background "white"))))
 '(company-tooltip-common ((t (:inherit company-tooltip :weight bold :underline nil))))
#+END_SRC
** Jumping Around the Buffer
#+BEGIN_SRC emacs-lisp
;; avy is "hint"-based motion. Type two leading chars of where you want to go
(define-key evil-normal-state-map (kbd "s") 'avy-goto-char-2)
(define-key evil-motion-state-map (kbd "s") 'avy-goto-char-2)
;; use avy as a vim motion
;; (disabled because it conflicts with vim paste operator)
;(define-key evil-motion-state-map (kbd "p") 'avy-goto-char-2)
#+END_SRC
** Copy/Paste
#+BEGIN_SRC emacs-lisp
(defun benv/copy-word-here (pt)
    (message "Calling")
    (save-excursion
    (goto-char pt)
    (kill-new (thing-at-point 'symbol))))

(defun benv/avy-word-regex (c)
   (concat
   "\\b"
   (string c)))

(defun benv/avy-copy-word-here (char)
   "Paste a word selected with avy"
   (interactive (list (read-char "char:" t)))
   (let ((avy-action 'benv/copy-word-here))
       (avy--generic-jump (benv/avy-word-regex char) nil avy-style)
       (yank)))

(spacemacs/declare-prefix "y" "yank")
(evil-leader/set-key
  "yw" 'benv/avy-copy-word-here)
#+END_SRC
* Clock
Display the time in the modeline.
#+BEGIN_SRC emacs-lisp
(setq display-time-default-load-average nil)
(display-time-mode t)
#+END_SRC
* Dired / Ranger / Deer
#+BEGIN_SRC emacs-lisp
;; if two dired windows are open, make the default
;; target of copy/move commands the other dired window
(setq dired-dwim-target t)

(defun dired-open-file ()
    "In dired, open the file named on this line."
    (interactive)
    (let* ((file (dired-get-filename nil t)))
        (call-process "xdg-open" nil 0 nil file)))

(add-hook 'dired-mode-hook 'dired-hide-details-mode)

;; Replace default `ranger-search-files`, used for
;; rapid navigation by fuzzy finding.  `helm-find-files-1`
;; does not correctly handle directory names
;; containing tilde (`~`), so I expand the tilde away with
;; `expand-file-name` first.
(defun ranger-search-files ()
  "Search for files / directories in folder."
  (interactive)
  (helm-find-files-1 (expand-file-name default-directory)))
#+END_SRC
* Direx
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'direx
  (add-hook 'direx:direx-mode-hook
			(lambda ()
			  (define-key evil-normal-state-local-map (kbd "RET") 'direx:display-item)
			  (define-key evil-normal-state-local-map (kbd "za") 'direx:toggle-item)
			  (define-key evil-normal-state-local-map (kbd "zc") 'direx:collapse-item)
			  (define-key evil-normal-state-local-map (kbd "zo") 'direx:expand-item)
			  (define-key evil-normal-state-local-map (kbd "zO") 'direx:expand-item-recursively))))
#+END_SRC
* ESS
#+BEGIN_SRC emacs-lisp
;; fixes ESS error when projectile has not yet been used/loaded
(autoload 'projectile-project-p "projectile")
#+END_SRC
* Evil Mode Settings
#+BEGIN_SRC emacs-lisp
;; don't permanently highlight search matches
(global-evil-search-highlight-persist nil)
;; don't move cursor left after escaping
;; from insert mode
(setq evil-move-cursor-back nil)
#+END_SRC
** evil-easymotion
#+BEGIN_SRC emacs-lisp
(evilem-default-keybindings "'")
#+END_SRC
* External Programs
#+BEGIN_SRC emacs-lisp
;; set default browser to firefox
(setq browse-url-browser-function 'browse-url-generic
	  browse-url-generic-program (case system-type
								   ((gnu/linux) "firefox")
								   ((cygwin) "cygstart")))
#+END_SRC
* Email
#+BEGIN_SRC emacs-lisp
(setq email-config-org "~/.emacs.d/private/local/email-config.org")
(if (file-exists-p email-config-org)
    (org-babel-load-file email-config-org))
#+END_SRC
* Flycheck
#+BEGIN_SRC emacs-lisp
(setq flycheck-display-errors-function 'flycheck-display-error-messages)
#+END_SRC
* GDB
#+BEGIN_SRC emacs-lisp
;; bring up one window with GDB REPL and one window with source code
(setq gdb-many-windows nil)
(setq gdb-show-main t)

;; Hack to show current source line while stepping in GDB:
;; highlight current line in buffer, even when window is
;; not focused
(setq global-hl-line-sticky-flag t)
(global-hl-line-mode)
#+END_SRC
* Helm
#+BEGIN_SRC emacs-lisp
;; workaround helm bug: https://github.com/syl20bnr/spacemacs/pull/9547
(require 'helm-bookmark)
#+END_SRC
* Code Indentation Settings
  #+BEGIN_SRC emacs-lisp
  ;; set default tab width to 4 spaces
  (setq-default tab-width 4)
  ;; use tabs for indentation
  (setq-default indent-tabs-mode t)

  (c-add-style "abyss-style"
	  '("linux"
		(indent-tabs-mode . t)
		(c-basic-offset . 4)
		(c-offsets-alist . ((inline-open . 0)
							(arglist-cont-nonempty . +)
							(arglist-cont . 0)
							(stream-op . +)))))

  (defun my-c++-mode-hook()
	(c-set-style "abyss-style"))

  (defun my-csharp-mode-hook()
	(my-c++-mode-hook)
	(setq company-idle-delay 0.1))

  (add-hook 'c-mode-common-hook 'my-c++-mode-hook)
  (add-hook 'csharp-mode-hook 'my-csharp-mode-hook)
  #+END_SRC
* Key Bindings
#+BEGIN_SRC emacs-lisp
;; custom keys for org mode
(evil-define-key 'normal evil-org-mode-map
 "L" 'org-demote-subtree
 "H" 'org-promote-subtree
 "\C-j" 'org-move-subtree-down
 "\C-k" 'org-move-subtree-up)
;; bindings for company mode
(define-key evil-insert-state-map (kbd "M-.") 'company-complete)
;; hippie expansion (buffer-based completion)
(define-key evil-insert-state-map (kbd "M-/") 'hippie-expand)
;; "zl" to fold all code blocks at current indentation level
(define-key evil-normal-state-map (kbd "zl") 'hs-hide-level)
#+END_SRC
* Line Numbering
#+BEGIN_SRC emacs-lisp
;; turn on line numbering
(global-linum-mode)
;; make line numbers relative to current line
(linum-relative-mode)
#+END_SRC
* Org Mode
** Org Babel

Some settings for source code blocks:

#+BEGIN_SRC emacs-lisp
(org-babel-do-load-languages 'org-babel-load-languages
'((dot . t) (asymptote . t)))
;; don't alter indentation (e.g. tabs vs. spaces) when embedding source code blocks
(setq org-src-preserve-indentation t)
;; edit source code in "other window" when pressing <C-'>
(setq org-src-window-setup 'other-window)
#+END_SRC

Set up a keybinding for hiding/showing all code blocks.  Also: hide all code blocks by default when first opening an org file.

#+BEGIN_SRC emacs-lisp
(defvar org-blocks-hidden nil)

(defun org-toggle-blocks ()
  (interactive)
  (if org-blocks-hidden
      (org-show-block-all)
    (org-hide-block-all))
  (setq-local org-blocks-hidden (not org-blocks-hidden)))

(add-hook 'org-mode-hook 'org-toggle-blocks)

(define-key org-mode-map (kbd "C-c t") 'org-toggle-blocks)
#+END_SRC
* Projectile
#+BEGIN_SRC emacs-lisp
;; FIX: make sure projectile using the correct `ctags` binary
(setq projectile-tags-command "ctags-exuberant -Re -f \"%s\" %s")
#+END_SRC
* rtags
#+BEGIN_SRC emacs-lisp
;; basic rtags setup

(setq rtags-lisp-directory "/projects/btl/benv/arch/centos6/linuxbrew-supplement/rtags-2.9/share/emacs/site-lisp/rtags")

(when (file-accessible-directory-p rtags-lisp-directory)
  (progn
	;; load rtags package
	(add-to-list 'load-path rtags-lisp-directory)
	(require 'rtags)

	;; start rtags automatically when editing C/C++ files
	(add-hook 'c-mode-common-hook 'rtags-start-process-unless-running)
	(add-hook 'c++-mode-common-hook 'rtags-start-process-unless-running)

	;; enable default keybindings
	(rtags-enable-standard-keybindings)

	;; custom keybindings
	(evil-leader/set-key-for-mode 'c-mode
	  "mgg" 'rtags-find-symbol-at-point
	  "mgs" 'rtags-find-symbol)
	(evil-leader/set-key-for-mode 'c++-mode
	  "mgg" 'rtags-find-symbol-at-point
	  "mgs" 'rtags-find-symbol)

	;; rtags-company
	(setq rtags-autostart-diagnostics t)
	(setq rtags-completions-enabled t)
	(push 'company-rtags company-backends)

	;; rtags-helm
	(require 'rtags-helm)
	(setq rtags-display-result-backend 'helm)

	;; flycheck-rtags
	(require 'flycheck-rtags)
	(defun my-flycheck-rtags-setup ()
	  (flycheck-select-checker 'rtags)
	  (setq-local flycheck-highlighting-mode nil) ;; RTags creates more accurate overlays.
	  (setq-local flycheck-check-syntax-automatically nil))
	(add-hook 'c-mode-hook #'my-flycheck-rtags-setup)
	(add-hook 'c++-mode-hook #'my-flycheck-rtags-setup)
	(add-hook 'objc-mode-hook #'my-flycheck-rtags-setup)))

#+END_SRC
* Shell
#+BEGIN_SRC emacs-lisp
;; set to bash instead of zsh to avoid avoid unsupported escape codes in prompt, etc.
(setq shell-file-name "/bin/bash")
(with-eval-after-load 'shell
  (evil-define-key 'normal shell-mode-map
	(kbd "C-a") 'beginning-of-line
	(kbd "C-e") 'end-of-line
	(kbd "C-k") 'kill-line
	(kbd "M-r") 'spacemacs/helm-shell-history)
  (evil-define-key 'insert shell-mode-map
	(kbd "C-a") 'beginning-of-line
	(kbd "C-e") 'end-of-line
	(kbd "C-k") 'kill-line
	(kbd "M-r") 'spacemacs/helm-shell-history))

(spacemacs/declare-prefix "am" "multishell")
(evil-leader/set-key
  "ams" (lambda() (interactive)
		  (setq current-prefix-arg '(4))
		  (call-interactively 'multishell-pop-to-shell)))
#+END_SRC
* Splitting Windows
#+BEGIN_SRC emacs-lisp
;; disable automatic window splitting
;; where possible
(setq-default split-width-threshold nil)
(setq split-width-threshold nil)
(setq-default split-height-threshold nil)
(setq split-height-threshold nil)
(shackle-mode)
(setq shackle-default-rule '(:same t))
#+END_SRC
